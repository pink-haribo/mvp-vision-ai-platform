"""
MMYOLO Default Config Template

This module provides the default MMEngine config template for MMYOLO training.
The template is used by train.py to generate runtime config files.

Usage:
    from default_config import get_config_template
    config_str = get_config_template(
        model_name='yolov8_s',
        dataset_dir='/path/to/dataset',
        work_dir='/path/to/work_dir',
        ...
    )
"""


def get_config_template(
    model_name: str,
    dataset_dir: str,
    work_dir: str,
    ann_file: str,
    img_prefix: str,
    class_names: list,
    num_classes: int,
    base_config: str,
    pretrained_url: str = None,
    # Training parameters
    epochs: int = 300,
    batch_size: int = 16,
    learning_rate: float = 0.01,
    warmup_epochs: int = 3,
    val_interval: int = 10,
    close_mosaic_epochs: int = 10,
    img_scale: tuple = (640, 640),
) -> str:
    """
    Generate MMYOLO config content.

    Args:
        model_name: Model name (e.g., 'yolov8_s')
        dataset_dir: Path to dataset directory
        work_dir: Working directory for outputs
        ann_file: Path to COCO annotation file
        img_prefix: Path to images directory
        class_names: List of class names
        num_classes: Number of classes
        base_config: Base config file path
        pretrained_url: URL to pretrained weights
        epochs: Number of training epochs
        batch_size: Batch size per GPU
        learning_rate: Base learning rate
        warmup_epochs: Number of warmup epochs
        val_interval: Validation interval (epochs)
        close_mosaic_epochs: Epochs before end to close mosaic
        img_scale: Image scale (width, height)

    Returns:
        Config file content as string
    """
    # Load pretrained weights line
    load_from_line = f"load_from = '{pretrained_url}'" if pretrained_url else ""

    config_content = f'''# Auto-generated MMYOLO config for {model_name}
# Generated by Vision AI Platform

_base_ = 'mmyolo::{base_config}'

# Dataset settings
data_root = '{dataset_dir}'

# Class names
class_name = {class_names}
num_classes = {num_classes}
metainfo = dict(classes=class_name)

# Override model head for custom classes
model = dict(
    bbox_head=dict(
        head_module=dict(num_classes={num_classes})
    )
)

# Dataset configuration
train_dataloader = dict(
    batch_size={batch_size},
    num_workers=4,
    persistent_workers=True,
    pin_memory=True,
    sampler=dict(type='DefaultSampler', shuffle=True),
    dataset=dict(
        type='YOLOv5CocoDataset',
        data_root=data_root,
        metainfo=metainfo,
        ann_file='{ann_file}',
        data_prefix=dict(img='{img_prefix}'),
        filter_cfg=dict(filter_empty_gt=False, min_size=32),
    )
)

val_dataloader = dict(
    batch_size={batch_size},
    num_workers=4,
    persistent_workers=True,
    pin_memory=True,
    drop_last=False,
    sampler=dict(type='DefaultSampler', shuffle=False),
    dataset=dict(
        type='YOLOv5CocoDataset',
        data_root=data_root,
        metainfo=metainfo,
        ann_file='{ann_file}',
        data_prefix=dict(img='{img_prefix}'),
        test_mode=True,
    )
)

test_dataloader = val_dataloader

# Evaluator
val_evaluator = dict(
    type='mmdet.CocoMetric',
    ann_file='{ann_file}',
    metric='bbox',
    format_only=False
)
test_evaluator = val_evaluator

# Training schedule
train_cfg = dict(
    type='EpochBasedTrainLoop',
    max_epochs={epochs},
    val_interval={val_interval},
    dynamic_intervals=[({epochs - close_mosaic_epochs}, 1)]
)
val_cfg = dict(type='ValLoop')
test_cfg = dict(type='TestLoop')

# Optimizer
optim_wrapper = dict(
    type='OptimWrapper',
    optimizer=dict(
        type='SGD',
        lr={learning_rate},
        momentum=0.937,
        weight_decay=0.0005,
        nesterov=True
    ),
    clip_grad=dict(max_norm=10.0)
)

# Learning rate scheduler
param_scheduler = [
    dict(type='LinearLR', start_factor=0.001, by_epoch=False, begin=0, end=1000),
    dict(type='CosineAnnealingLR', T_max={epochs - warmup_epochs}, eta_min=0.0001, by_epoch=True, begin={warmup_epochs}, end={epochs})
]

# Runtime hooks
custom_hooks = [
    dict(
        type='EMAHook',
        ema_type='ExpMomentumEMA',
        momentum=0.0001,
        update_buffers=True,
        strict_load=False,
        priority=49
    ),
'''

    # Add mosaic/mixup switch hook
    if close_mosaic_epochs > 0:
        config_content += f'''
    dict(
        type='mmdet.PipelineSwitchHook',
        switch_epoch={epochs - close_mosaic_epochs},
        switch_pipeline=[
            dict(type='LoadImageFromFile'),
            dict(type='LoadAnnotations', with_bbox=True),
            dict(type='YOLOv5KeepRatioResize', scale={img_scale}),
            dict(type='LetterResize', scale={img_scale}, allow_scale_up=True, pad_val=dict(img=114)),
            dict(type='YOLOv5RandomAffine', max_rotate_degree=0.0, max_shear_degree=0.0, scaling_ratio_range=(0.5, 1.5), border=(-{img_scale[0] // 2}, -{img_scale[1] // 2}), border_val=(114, 114, 114)),
            dict(type='mmdet.PackDetInputs', meta_keys=('img_id', 'img_path', 'ori_shape', 'img_shape', 'scale_factor', 'pad_param'))
        ]
    )
'''

    config_content += f''']

default_hooks = dict(
    timer=dict(type='IterTimerHook'),
    logger=dict(type='LoggerHook', interval=50),
    param_scheduler=dict(type='ParamSchedulerHook'),
    checkpoint=dict(type='CheckpointHook', interval=10, save_best='coco/bbox_mAP', rule='greater', max_keep_ckpts=3),
    sampler_seed=dict(type='DistSamplerSeedHook'),
    visualization=dict(type='mmdet.DetVisualizationHook')
)

# Work directory
work_dir = '{work_dir}'

# Randomness
randomness = dict(seed=42, deterministic=False)

{load_from_line}
'''

    return config_content
